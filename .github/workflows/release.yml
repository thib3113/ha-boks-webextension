name: Build, Sign and Publish Extension

# Trigger on published releases
on:
  release:
    types: [published]

# Grant id-token so cosign keyless can use OIDC
permissions:
  contents: write
  id-token: write

jobs:
  build-and-attach:
    name: Build, Sign and Attach Assets
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js & tools
        uses: actions/setup-node@v4
        with:
          node-version: 'lts/*'

      - name: Prepare build directories (copy only src)
        run: |
          set -euo pipefail
          rm -rf build firefox_dist chrome_build provenance
          mkdir -p build chrome_build firefox_dist provenance

          # Copy extension source to a clean build dir (avoid .github, .git, node_modules, etc.)
          rsync -a --delete --exclude='.git' --exclude='.github' --exclude='node_modules' src/ chrome_build/
          rsync -a --delete --exclude='.git' --exclude='.github' --exclude='node_modules' src/ firefox_dist/

          echo "Prepared chrome_build/ and firefox_dist/ from src/"
        shell: bash

      - name: Create Firefox XPI
        run: |
          set -euo pipefail
          cd firefox_dist

          if [ -f manifest.json ]; then
            # Add browser_specific_settings.gecko.id if not present
            if ! jq -e '.browser_specific_settings.gecko.id' manifest.json >/dev/null 2>&1; then
              jq '.browser_specific_settings = { "gecko": { "id": "55082b69-ecc1-46ce-8dcd-90c30df203b1" } }' manifest.json > manifest.tmp && mv manifest.tmp manifest.json
            fi
          fi

          # Create an XPI (ZIP with .xpi extension)
          FIREFOX_NAME="firefox-ha-boks-extension.xpi"
          zip -r "../${FIREFOX_NAME}" .
          cd ..
          echo "Created ${FIREFOX_NAME}"
        shell: bash

      - name: Install crx3 & Pack Chrome ZIP + CRX
        id: pack_crx
        env:
          RELEASE_TAG: ${{ github.event.release.tag_name }}
          GITHUB_SERVER_URL: ${{ github.server_url }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          CRX_PRIVATE_KEY: ${{ secrets.CRX_KEY }}
        run: |
          set -euo pipefail
          BASE="ha-boks-extension"
          CHROME_CRX="chrome-${BASE}.crx"
          ZIP_NAME="${BASE}.zip"

          if [ -z "${CRX_PRIVATE_KEY:-}" ]; then
            echo "No CRX private key supplied â€” skipping CRX pack step."
            exit 0
          fi

          KEYFILE=private.pem
          if printf '%s' "$CRX_PRIVATE_KEY" | grep -q "BEGIN"; then
            printf '%s\n' "$CRX_PRIVATE_KEY" > "$KEYFILE"
          else
            echo "$CRX_PRIVATE_KEY" | base64 --decode > "$KEYFILE" || { echo "Failed to decode CRX_KEY as base64"; exit 4; }
          fi
          chmod 600 "$KEYFILE"

          if [ -z "${RELEASE_TAG:-}" ]; then
            CRX_URL=""
          else
            CRX_URL="${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/releases/download/${RELEASE_TAG}/${CHROME_CRX}"
          fi
          echo "Computed CRX URL: ${CRX_URL}"

          APP_VERSION=""
          if [ -n "${RELEASE_TAG:-}" ]; then
            APP_VERSION="${RELEASE_TAG#v}"
            APP_VERSION="${APP_VERSION#V}"
          fi
          if [ -z "${APP_VERSION}" ] && [ -f chrome_build/manifest.json ]; then
            APP_VERSION=$(jq -r '.version // empty' chrome_build/manifest.json || true)
          fi
          if [ -z "${APP_VERSION}" ]; then APP_VERSION="0.0.0"; fi

          if [ -n "${CRX_URL}" ]; then
            npx --yes crx3 pack chrome_build -p "$KEYFILE" -o "${CHROME_CRX}" -z "${ZIP_NAME}" --appVersion "$APP_VERSION" --crxURL "$CRX_URL" || { echo "crx3 packing failed"; rm -f "$KEYFILE"; exit 5; }
          else
            npx --yes crx3 pack chrome_build -p "$KEYFILE" -o "${CHROME_CRX}" -z "${ZIP_NAME}" --appVersion "$APP_VERSION" || { echo "crx3 packing failed"; rm -f "$KEYFILE"; exit 5; }
          fi

          shred -u "$KEYFILE" 2>/dev/null || rm -f "$KEYFILE"
          echo "CRX and Chrome ZIP created: ${CHROME_CRX}, ${ZIP_NAME}"
        shell: bash

      - name: Install cosign
        run: |
          set -euo pipefail

          # Pin a recent cosign release known to support keyless behaviour for sign-blob
          COSIGN_VERSION="v2.4.1"
          COSIGN_BIN="/usr/local/bin/cosign"

          echo "Attempting to download cosign ${COSIGN_VERSION} to ${COSIGN_BIN}..."
          if curl -fSL "https://github.com/sigstore/cosign/releases/download/${COSIGN_VERSION}/cosign-linux-amd64" -o "$COSIGN_BIN"; then
            chmod +x "$COSIGN_BIN"
            echo "Downloaded cosign to $COSIGN_BIN"
          else
            echo "Failed to download cosign binary from GitHub releases. Will try docker image fallback..."
            if command -v docker >/dev/null 2>&1; then
              docker run --rm --entrypoint cat "ghcr.io/sigstore/cosign/cosign:${COSIGN_VERSION}" /ko-app/cosign > "$COSIGN_BIN"
              chmod +x "$COSIGN_BIN"
              echo "Extracted cosign from GHCR image to $COSIGN_BIN"
            else
              echo "ERROR: could not download cosign and docker not available for fallback. Exiting."
              exit 2
            fi
          fi

          echo "Checking cosign binary at $COSIGN_BIN"
          # Try both 'version' and '--version' to be tolerant with variants
          if "$COSIGN_BIN" version >/dev/null 2>&1; then
            "$COSIGN_BIN" version || true
          elif "$COSIGN_BIN" --version >/dev/null 2>&1; then
            "$COSIGN_BIN" --version || true
          else
            echo "Warning: cosign did not accept 'version' or '--version' flags. Continuing, will check sign-blob help next."
          fi

          # Ensure sign-blob supports non-key signing (we avoid using --keyless flag)
          if ! "$COSIGN_BIN" sign-blob --help 2>&1 | grep -q -- '--output-signature'; then
            echo "ERROR: the installed cosign ($COSIGN_BIN) does not appear to support sign-blob with --output-signature."
            echo "Output of $COSIGN_BIN sign-blob --help:"
            "$COSIGN_BIN" sign-blob --help 2>&1 || true
            echo "Please pick a newer cosign release. Failing job to let you fix it."
            exit 4
          fi

          echo "Cosign installed and basic sign-blob support present. Exporting COSIGN_BIN"
          echo "COSIGN_BIN=$COSIGN_BIN" >> "$GITHUB_ENV"
        shell: bash

      - name: Sign all artifacts with cosign (keyless) and record provenance
        if: success() && steps.pack_crx.outcome == 'success'
        env:
          COSIGN_EXPERIMENTAL: "1"
          RELEASE_TAG: ${{ github.event.release.tag_name }}
          GITHUB_SERVER_URL: ${{ github.server_url }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail
          COSIGN_BIN="${COSIGN_BIN:-/usr/local/bin/cosign}"
          mkdir -p provenance

          BASE="ha-boks-extension"
          CHROME_CRX="chrome-${BASE}.crx"
          ZIP_NAME="${BASE}.zip"
          FIREFOX_NAME="firefox-${BASE}.xpi"

          artifacts=(
            "${ZIP_NAME}"
            "${FIREFOX_NAME}"
            "${CHROME_CRX}"
          )

          # certificate identity regexp (matches repo URL in cert 'subject' or 'extensions')
          CERT_IDENTITY_REGEXP="${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}.*"
          # certificate oidc issuer regexp: GitHub Actions OIDC provider
          CERT_OIDC_ISSUER_REGEXP="${CERT_OIDC_ISSUER_REGEXP:-https://token.actions.githubusercontent.com.*}"

          echo "Using certificate identity regexp: $CERT_IDENTITY_REGEXP"
          echo "Using certificate oidc issuer regexp: $CERT_OIDC_ISSUER_REGEXP"

          for f in "${artifacts[@]}"; do
            if [ ! -f "$f" ]; then
              echo "Warning: $f not found, skipping signing."
              continue
            fi

            sig="${f}.sig"
            cert="${f}.cert"
            prov="provenance/${f}.verify.txt"

            echo "Signing $f -> $sig (non-interactive; cosign will use Actions OIDC if available)"
            "$COSIGN_BIN" sign-blob -y --oidc-provider github-actions --output-signature "$sig" --output-certificate "$cert" "$f"

            echo "Verifying $f and saving output to $prov"
            # verify with certificate file and require expected certificate identity and issuer regexps
            "$COSIGN_BIN" verify-blob --signature "$sig" --cert "$cert" --certificate-identity-regexp "$CERT_IDENTITY_REGEXP" --certificate-oidc-issuer-regexp "$CERT_OIDC_ISSUER_REGEXP" "$f" 2>&1 | tee "$prov"

            echo "Signed $f -> $sig and $cert; verification written to $prov"
          done
        shell: bash

      - name: List artifacts for debug
        run: |
          echo "Artifacts in workspace:"
          ls -alh
          echo "--- ha-boks-extension.zip content (if present) ---"
          test -f ha-boks-extension.zip && unzip -l ha-boks-extension.zip || true
          echo "--- firefox-ha-boks-extension.xpi content (if present) ---"
          test -f firefox-ha-boks-extension.xpi && unzip -l firefox-ha-boks-extension.xpi || true
          echo "--- chrome-ha-boks-extension.crx present? ---"
          test -f chrome-ha-boks-extension.crx && echo "Found chrome-ha-boks-extension.crx" || true
          echo "--- provenance files ---"
          ls -alh provenance || true
        shell: bash

      - name: Upload Assets to Release (including signatures & provenance)
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { repo, owner } = context.repo;
            const releaseId = context.payload.release.id;
            console.log(`Uploading assets to release ID: ${releaseId}`);

            const files = [
              'ha-boks-extension.zip',
              'ha-boks-extension.zip.sig',
              'ha-boks-extension.zip.cert',
              'provenance/ha-boks-extension.zip.verify.txt',

              'firefox-ha-boks-extension.xpi',
              'firefox-ha-boks-extension.xpi.sig',
              'firefox-ha-boks-extension.xpi.cert',
              'provenance/firefox-ha-boks-extension.xpi.verify.txt',

              'chrome-ha-boks-extension.crx',
              'chrome-ha-boks-extension.crx.sig',
              'chrome-ha-boks-extension.crx.cert',
              'provenance/chrome-ha-boks-extension.crx.verify.txt'
            ];

            for (const file of files) {
              if (fs.existsSync(file)) {
                console.log(`Uploading ${file}...`);
                await github.rest.repos.uploadReleaseAsset({
                  owner,
                  repo,
                  release_id: releaseId,
                  name: file,
                  data: fs.readFileSync(file)
                });
                console.log(`Uploaded ${file}`);
              } else {
                console.log(`File ${file} skipped (not found).`);
              }
            }
        env:
          RELEASE_TAG: ${{ github.event.release.tag_name }}
          GITHUB_SERVER_URL: ${{ github.server_url }}
          GITHUB_REPOSITORY: ${{ github.repository }}

      - name: Append verification instructions to release notes
        uses: actions/github-script@v7
        env:
          RELEASE_TAG: ${{ github.event.release.tag_name }}
          GITHUB_SERVER_URL: ${{ github.server_url }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        with:
          script: |
            const { owner, repo } = context.repo;
            const releaseId = context.payload.release.id;
            const tag = process.env.RELEASE_TAG || context.payload.release.tag_name || '';
            const base = `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/releases/download/${tag}`;

            // Build the recommended certificate identity & issuer regexps to use with cosign verify-blob
            const certRegexp = `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}.*`;
            const issuerRegexp = 'https://token.actions.githubusercontent.com.*';

            const verificationBlock = [
              '',
              '## Signature verification (Provenance)',
              '',
              'The artifacts published with this release are signed using Sigstore / cosign (keyless mode when available).',
              'To verify locally that the files were produced by this build, install cosign and run, for example:',
              '',
              `- CRX (Chrome): \`cosign verify-blob --signature chrome-ha-boks-extension.crx.sig --certificate-identity-regexp \"${certRegexp}\" --certificate-oidc-issuer-regexp \"${issuerRegexp}\" ${base}/chrome-ha-boks-extension.crx\``,
              `- Chrome ZIP: \`cosign verify-blob --signature ha-boks-extension.zip.sig --certificate-identity-regexp \"${certRegexp}\" --certificate-oidc-issuer-regexp \"${issuerRegexp}\" ${base}/ha-boks-extension.zip\``,
              `- Firefox XPI: \`cosign verify-blob --signature firefox-ha-boks-extension.xpi.sig --certificate-identity-regexp \"${certRegexp}\" --certificate-oidc-issuer-regexp \"${issuerRegexp}\" ${base}/firefox-ha-boks-extension.xpi\``,
              '',
              'You can also inspect the attached provenance files (provenance/*.verify.txt) which contain the detailed verification output (claims, Rekor entry).',
              '',
              'Quick docs: https://github.com/sigstore/cosign',
              ''
            ].join('\n');

            const current = context.payload.release.body || '';
            const newBody = current + '\n\n' + verificationBlock;

            await github.rest.repos.updateRelease({
              owner,
              repo,
              release_id: releaseId,
              body: newBody
            });
