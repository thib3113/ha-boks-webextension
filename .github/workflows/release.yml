name: Build, Sign and Publish Extension

# Trigger on published releases
on:
  release:
    types: [published]

# Grant id-token so cosign keyless can use OIDC
permissions:
  contents: write
  id-token: write

jobs:
  build-and-attach:
    name: Build, Sign and Attach Assets
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js & tools
        uses: actions/setup-node@v4
        with:
          node-version: 'lts/*'

      - name: Prepare build directories (copy only src)
        run: |
          set -euo pipefail
          rm -rf build firefox_dist chrome_build provenance
          mkdir -p build chrome_build firefox_dist provenance

          # Copy extension source to a clean build dir (avoid .github, .git, node_modules, etc.)
          rsync -a --delete --exclude='.git' --exclude='.github' --exclude='node_modules' src/ chrome_build/
          rsync -a --delete --exclude='.git' --exclude='.github' --exclude='node_modules' src/ firefox_dist/

          echo "Prepared chrome_build/ and firefox_dist/ from src/"
        shell: bash

      - name: Create Firefox XPI
        run: |
          set -euo pipefail
          cd firefox_dist

          if [ -f manifest.json ]; then
            # Add browser_specific_settings.gecko.id if not present
            if ! jq -e '.browser_specific_settings.gecko.id' manifest.json >/dev/null 2>&1; then
              jq '.browser_specific_settings = { "gecko": { "id": "55082b69-ecc1-46ce-8dcd-90c30df203b1" } }' manifest.json > manifest.tmp && mv manifest.tmp manifest.json
            fi
          fi

          # Create an XPI (ZIP with .xpi extension)
          FIREFOX_NAME="firefox-ha-boks-extension.xpi"
          zip -r "../${FIREFOX_NAME}" .
          cd ..
          echo "Created ${FIREFOX_NAME}"
        shell: bash

      - name: Install crx3 & Pack Chrome ZIP + CRX
        id: pack_crx
        env:
          RELEASE_TAG: ${{ github.event.release.tag_name }}
          GITHUB_SERVER_URL: ${{ github.server_url }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          CRX_PRIVATE_KEY: ${{ secrets.CRX_KEY }}
        run: |
          set -euo pipefail

          BASE="ha-boks-extension"
          CHROME_CRX="chrome-${BASE}.crx"
          ZIP_NAME="${BASE}.zip"

          if [ -z "${CRX_PRIVATE_KEY:-}" ]; then
            echo "No CRX private key supplied — skipping CRX pack step."
            exit 0
          fi

          # Prepare keyfile: support PEM in cleartext or base64-encoded secret
          KEYFILE=private.pem
          if printf '%s' "$CRX_PRIVATE_KEY" | grep -q "BEGIN"; then
            printf '%s\n' "$CRX_PRIVATE_KEY" > "$KEYFILE"
          else
            echo "$CRX_PRIVATE_KEY" | base64 --decode > "$KEYFILE" || { echo "Failed to decode CRX_KEY as base64"; exit 4; }
          fi
          chmod 600 "$KEYFILE"

          # Compute CRX URL automatically from the release tag and repository
          if [ -z "${RELEASE_TAG:-}" ]; then
            echo "Release tag is empty — cannot compute CRX URL"
            CRX_URL=""
          else
            CRX_URL="${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/releases/download/${RELEASE_TAG}/${CHROME_CRX}"
          fi
          echo "Computed CRX URL: ${CRX_URL}"

          # Determine APP_VERSION: prefer release tag (strip leading v/V), fallback to manifest.json
          APP_VERSION=""
          if [ -n "${RELEASE_TAG:-}" ]; then
            APP_VERSION="${RELEASE_TAG#v}"
            APP_VERSION="${APP_VERSION#V}"
            echo "Using release tag as version (stripped): $APP_VERSION"
          fi

          if [ -z "${APP_VERSION}" ]; then
            if [ -f chrome_build/manifest.json ]; then
              APP_VERSION=$(jq -r '.version // empty' chrome_build/manifest.json || true)
              echo "Using version from manifest.json: ${APP_VERSION}"
            fi
          fi

          if [ -z "${APP_VERSION}" ]; then
            APP_VERSION="0.0.0"
            echo "No version found in release tag or manifest.json, using fallback: ${APP_VERSION}"
          fi

          echo "Packing CRX from chrome_build/ with appVersion=${APP_VERSION} ..."
          # Use npx to ensure crx3 is available without global install
          if [ -n "${CRX_URL}" ]; then
            npx --yes crx3 pack chrome_build -p "$KEYFILE" -o "${CHROME_CRX}" -z "${ZIP_NAME}" --appVersion "$APP_VERSION" --crxURL "$CRX_URL" || { echo "crx3 packing failed"; rm -f "$KEYFILE"; exit 5; }
          else
            npx --yes crx3 pack chrome_build -p "$KEYFILE" -o "${CHROME_CRX}" -z "${ZIP_NAME}" --appVersion "$APP_VERSION" || { echo "crx3 packing failed"; rm -f "$KEYFILE"; exit 5; }
          fi

          # Securely remove key
          shred -u "$KEYFILE" 2>/dev/null || rm -f "$KEYFILE"

          echo "CRX and Chrome ZIP created: ${CHROME_CRX}, ${ZIP_NAME}"
        shell: bash

      - name: Install cosign
        run: |
          set -euo pipefail

          # Pin a recent cosign release known to support keyless sign-blob/verify-blob
          COSIGN_VERSION="v2.4.1"
          COSIGN_BIN="/usr/local/bin/cosign"

          echo "Attempting to download cosign ${COSIGN_VERSION} to ${COSIGN_BIN}..."
          if curl -fSL "https://github.com/sigstore/cosign/releases/download/${COSIGN_VERSION}/cosign-linux-amd64" -o "$COSIGN_BIN"; then
            chmod +x "$COSIGN_BIN"
            echo "Downloaded cosign to $COSIGN_BIN"
          else
            echo "Failed to download cosign binary from GitHub releases. Will try docker image fallback..."
            # fallback: extract binary from official GHCR image (requires docker available)
            if command -v docker >/dev/null 2>&1; then
              docker run --rm --entrypoint cat "ghcr.io/sigstore/cosign/cosign:${COSIGN_VERSION}" /ko-app/cosign > "$COSIGN_BIN"
              chmod +x "$COSIGN_BIN"
              echo "Extracted cosign from GHCR image to $COSIGN_BIN"
            else
              echo "ERROR: could not download cosign and docker not available for fallback. Exiting."
              exit 2
            fi
          fi

          echo "Checking cosign binary at $COSIGN_BIN"
          # Basic file check
          if ! file "$COSIGN_BIN" | grep -q -E 'ELF|Mach-O|executable'; then
            echo "ERROR: downloaded cosign does not look like a valid executable:"
            file "$COSIGN_BIN"
            ls -l "$COSIGN_BIN" || true
            exit 3
          fi

          # Try both 'version' and '--version' to be tolerant with variants
          echo "Trying '$COSIGN_BIN version'..."
          if "$COSIGN_BIN" version >/dev/null 2>&1; then
            "$COSIGN_BIN" version || true
          else
            echo "Trying '$COSIGN_BIN --version'..."
            if "$COSIGN_BIN" --version >/dev/null 2>&1; then
              "$COSIGN_BIN" --version || true
            else
              echo "Warning: cosign did not accept 'version' or '--version' flags. Continuing, will check sign-blob help next."
            fi
          fi

          # Ensure sign-blob advertises --keyless
          if ! "$COSIGN_BIN" sign-blob --help 2>&1 | grep -q -- '--keyless'; then
            echo "ERROR: the installed cosign ($COSIGN_BIN) does not advertise --keyless for sign-blob."
            echo "Output of $COSIGN_BIN sign-blob --help:"
            "$COSIGN_BIN" sign-blob --help 2>&1 || true
            echo "Please pick a newer cosign release (e.g. v2.4.1) or update the installation URL. Failing job to let you fix it."
            exit 4
          fi

          echo "Cosign installed and supports --keyless. Exporting COSIGN_BIN"
          echo "COSIGN_BIN=$COSIGN_BIN" >> "$GITHUB_ENV"
        shell: bash

      - name: Sign all artifacts with cosign (keyless) and record provenance
        if: success() && steps.pack_crx.outcome == 'success'
        env:
          COSIGN_EXPERIMENTAL: "1"
          RELEASE_TAG: ${{ github.event.release.tag_name }}
          GITHUB_SERVER_URL: ${{ github.server_url }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail
          COSIGN_BIN="${COSIGN_BIN:-/usr/local/bin/cosign}"
          mkdir -p provenance

          # check if the installed cosign supports keyless for sign-blob
          if ! "$COSIGN_BIN" sign-blob --help 2>&1 | grep -q -- '--keyless'; then
            echo "Error: the installed cosign ($COSIGN_BIN) does not advertise --keyless for sign-blob."
            echo "Output of $COSIGN_BIN --version:"
            "$COSIGN_BIN" --version || true
            echo "Please ensure cosign >= v1.7.0 (or a recent release) is installed. Failing the job so you can fix the runner."
            exit 2
          fi

          BASE="ha-boks-extension"
          CHROME_CRX="chrome-${BASE}.crx"
          ZIP_NAME="${BASE}.zip"
          FIREFOX_NAME="firefox-${BASE}.xpi"

          artifacts=(
            "${ZIP_NAME}"
            "${FIREFOX_NAME}"
            "${CHROME_CRX}"
          )

          for f in "${artifacts[@]}"; do
            if [ ! -f "$f" ]; then
              echo "Warning: $f not found, skipping signing."
              continue
            fi

            sig="${f}.sig"
            cert="${f}.cert"
            prov="provenance/${f}.verify.txt"

            echo "Signing $f -> $sig"
            # call the explicit binary to avoid picking a system cosign
            "$COSIGN_BIN" sign-blob --keyless --output-signature "$sig" "$f"

            echo "Verifying $f and saving output to $prov"
            "$COSIGN_BIN" verify-blob --keyless --signature "$sig" --cert "$cert" "$f" 2>&1 | tee "$prov"

            echo "Signed $f -> $sig and $cert; verification written to $prov"
          done
        shell: bash

      - name: List artifacts for debug
        run: |
          echo "Artifacts in workspace:"
          ls -alh
          echo "--- chrome ZIP content (if present) ---"
          test -f ha-boks-extension.zip && unzip -l ha-boks-extension.zip || true
          echo "--- firefox XPI content (if present) ---"
          test -f firefox-ha-boks-extension.xpi && unzip -l firefox-ha-boks-extension.xpi || true
          echo "--- CRX present? ---"
          test -f chrome-ha-boks-extension.crx && echo "Found chrome-ha-boks-extension.crx" || true
          echo "--- provenance files ---"
          ls -alh provenance || true
        shell: bash

      - name: Upload Assets to Release (including signatures & provenance)
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { repo, owner } = context.repo;
            const releaseId = context.payload.release.id;
            console.log(`Uploading assets to release ID: ${releaseId}`);

            const files = [
              'ha-boks-extension.zip',
              'ha-boks-extension.zip.sig',
              'ha-boks-extension.zip.cert',
              'provenance/ha-boks-extension.zip.verify.txt',

              'firefox-ha-boks-extension.xpi',
              'firefox-ha-boks-extension.xpi.sig',
              'firefox-ha-boks-extension.xpi.cert',
              'provenance/firefox-ha-boks-extension.xpi.verify.txt',

              'chrome-ha-boks-extension.crx',
              'chrome-ha-boks-extension.crx.sig',
              'chrome-ha-boks-extension.crx.cert',
              'provenance/chrome-ha-boks-extension.crx.verify.txt'
            ];

            for (const file of files) {
              if (fs.existsSync(file)) {
                console.log(`Uploading ${file}...`);
                await github.rest.repos.uploadReleaseAsset({
                  owner,
                  repo,
                  release_id: releaseId,
                  name: file,
                  data: fs.readFileSync(file)
                });
                console.log(`Uploaded ${file}`);
              } else {
                console.log(`File ${file} skipped (not found).`);
              }
            }
        env:
          RELEASE_TAG: ${{ github.event.release.tag_name }}
          GITHUB_SERVER_URL: ${{ github.server_url }}
          GITHUB_REPOSITORY: ${{ github.repository }}

      - name: Append verification instructions to release notes
        uses: actions/github-script@v7
        env:
          RELEASE_TAG: ${{ github.event.release.tag_name }}
          GITHUB_SERVER_URL: ${{ github.server_url }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        with:
          script: |
            const { owner, repo } = context.repo;
            const releaseId = context.payload.release.id;
            const tag = process.env.RELEASE_TAG || context.payload.release.tag_name || '';
            const base = `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/releases/download/${tag}`;

            const verificationBlock = [
              '',
              '## Signature verification (Provenance)',
              '',
              'The artifacts published with this release are signed using Sigstore / cosign (keyless mode).',
              'To verify locally that the files were produced by this build, install cosign and run, for example:',
              '',
              `- CRX (Chrome): \`cosign verify-blob --keyless --signature chrome-ha-boks-extension.crx.sig ${base}/chrome-ha-boks-extension.crx\``,
              `- Chrome ZIP: \`cosign verify-blob --keyless --signature ha-boks-extension.zip.sig ${base}/ha-boks-extension.zip\``,
              `- Firefox XPI: \`cosign verify-blob --keyless --signature firefox-ha-boks-extension.xpi.sig ${base}/firefox-ha-boks-extension.xpi\``,
              '',
              'You can also inspect the attached provenance files (provenance/*.verify.txt) which contain the detailed verification output (claims, Rekor entry).',
              '',
              'Quick docs: https://github.com/sigstore/cosign',
              ''
            ].join('\n');

            const current = context.payload.release.body || '';
            const newBody = current + '\n\n' + verificationBlock;

            await github.rest.repos.updateRelease({
              owner,
              repo,
              release_id: releaseId,
              body: newBody
            });

            console.log('Release notes updated with verification instructions.');
